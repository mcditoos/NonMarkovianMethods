{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NonMarkovian methods documentation","text":""},{"location":"#for-now-it-only-handles-the-refined-weak-coupling-limitcumulant-equation","title":"For now it only handles the Refined Weak Coupling limit/Cumulant equation","text":""},{"location":"api/","title":"API reference","text":""},{"location":"api/#nmm.utils.baths","title":"<code>baths</code>","text":""},{"location":"api/#nmm.utils.baths.BosonicBath","title":"<code>BosonicBath</code>","text":"Source code in <code>nmm/utils/baths.py</code> <pre><code>class BosonicBath:\n    def __init__(self, T):\n        self.T = T\n\n    def bose(self, \u03bd):\n        r\"\"\"\n        It computes the Bose-Einstein distribution\n\n        $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n        Parameters:\n        ----------\n        \u03bd: float\n            The mode at which to compute the thermal population\n\n        Returns:\n        -------\n        float\n            The thermal population of mode \u03bd\n        \"\"\"\n        if self.T == 0:\n            return 0\n        if \u03bd == 0:\n            return 0\n        return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n\n    def spectral_density(self, w):\n        return None\n\n    def correlation_function(self, t):\n        return None\n\n    def power_spectrum(self, w):\n        return 2*(self.bose(w)+1)*self.spectral_density(w)\n</code></pre>"},{"location":"api/#nmm.utils.baths.BosonicBath.bose","title":"<code>bose(\u03bd)</code>","text":"<p>It computes the Bose-Einstein distribution</p> \\[ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} \\] Parameters: <p>\u03bd: float     The mode at which to compute the thermal population</p> Returns: <p>float     The thermal population of mode \u03bd</p> Source code in <code>nmm/utils/baths.py</code> <pre><code>def bose(self, \u03bd):\n    r\"\"\"\n    It computes the Bose-Einstein distribution\n\n    $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n    Parameters:\n    ----------\n    \u03bd: float\n        The mode at which to compute the thermal population\n\n    Returns:\n    -------\n    float\n        The thermal population of mode \u03bd\n    \"\"\"\n    if self.T == 0:\n        return 0\n    if \u03bd == 0:\n        return 0\n    return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n</code></pre>"},{"location":"api/#nmm.utils.baths.OhmicBath","title":"<code>OhmicBath</code>","text":"<p>             Bases: <code>BosonicBath</code></p> Source code in <code>nmm/utils/baths.py</code> <pre><code>class OhmicBath(BosonicBath):\n    def __init__(self, T, alpha, wc):\n        super().__init__(T)\n        self.alpha = alpha\n        self.wc = wc\n\n    def spectral_density(self, w):\n        r\"\"\"\n        It describes the spectral density of an Ohmic spectral density given by\n\n        $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n        Parameters\n        ----------\n        \"\"\"\n        return self.alpha*w*np.exp(-abs(w)/self.wc)\n\n    def correlation_function(self, t):\n        return None\n</code></pre>"},{"location":"api/#nmm.utils.baths.OhmicBath.spectral_density","title":"<code>spectral_density(w)</code>","text":"<p>It describes the spectral density of an Ohmic spectral density given by</p> \\[ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} \\] Source code in <code>nmm/utils/baths.py</code> <pre><code>def spectral_density(self, w):\n    r\"\"\"\n    It describes the spectral density of an Ohmic spectral density given by\n\n    $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n    Parameters\n    ----------\n    \"\"\"\n    return self.alpha*w*np.exp(-abs(w)/self.wc)\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant","title":"<code>cumulant</code>","text":""},{"location":"api/#nmm.cumulant.cumulant.csolve","title":"<code>csolve</code>","text":"Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>class csolve:\n    def __init__(self, Hsys, t, bath, Q, eps=1e-4):\n        self.Hsys = Hsys\n        self.t = t\n        self.eps = eps\n        self.bose = bath.bose\n        self.spectral_density = bath.spectral_density\n        self.Q = Q\n\n    def \u03b3fa(self, w, w1, t):\n        r\"\"\"\n        It describes the decay rates for the Filtered Approximation of the\n        cumulant equation\n\n        $$\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime\n        -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)\n         \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)\n         \\right)^{\\frac{1}{2}}$$\n\n        Parameters\n        ----------\n\n        w : float or numpy.ndarray\n\n        w1 : float or numpy.ndarray\n\n        t : float or numpy.ndarray\n\n        Returns\n        -------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n        var = (2 * np.pi * t * np.exp(1j * (w1 - w) * t / 2)\n               * np.sinc((w1 - w) * t / (2 * np.pi))\n               * np.sqrt(self.spectral_density(w1) * (self.bose(w1) + 1))\n               * np.sqrt(self.spectral_density(w) * (self.bose(w) + 1)))\n        return var\n\n    def _\u03b3(self, \u03bd, w, w1, t):\n        r\"\"\"\n        It describes the Integrand of the decay rates of the cumulant equation\n        for bosonic baths\n\n        $$\\Gamma(w,w',t)=\\int_{0}^{t} dt_1 \\int_{0}^{t} dt_2\n        e^{i (w t_1 - w' t_2)} \\mathcal{C}(t_{1},t_{2})$$\n\n        Parameters:\n        ----------\n\n        w: float or numpy.ndarray\n\n        w1: float or numpy.ndarray\n\n        t: float or numpy.ndarray\n\n        Returns:\n        --------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n        var = (\n            np.exp(1j * (w - w1) / 2 * t)\n            * self.spectral_density(\u03bd)\n            * (np.sinc((w - \u03bd) / (2 * np.pi) * t)\n               * np.sinc((w1 - \u03bd) / (2 * np.pi) * t))\n            * (self.bose(\u03bd) + 1)\n        )\n        var += (\n            np.exp(1j * (w - w1) / 2 * t)\n            * self.spectral_density(\u03bd)\n            * (np.sinc((w + \u03bd) / (2 * np.pi) * t)\n               * np.sinc((w1 + \u03bd) / (2 * np.pi) * t))\n            * self.bose(\u03bd)\n        )\n        return var\n\n    def \u0393gen(self, w, w1, t, approximated=False):\n        r\"\"\"\n        It describes the the decay rates of the cumulant equation\n        for bosonic baths\n\n        $$\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega \n        e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1) \n        sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right)\n        sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega) \n        sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right) \n        sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]$$\n\n        Parameters\n        ----------\n\n        w : float or numpy.ndarray\n        w1 : float or numpy.ndarray\n        t : float or numpy.ndarray\n\n        Returns\n        -------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n        if approximated:\n            return self.\u03b3fa(w, w1, t)\n        else:\n            integrals = quad_vec(\n                self._\u03b3,\n                0,\n                np.Inf,\n                args=(w, w1, t),\n                epsabs=self.eps,\n                epsrel=self.eps,\n                quadrature=\"gk15\"\n            )[0]\n            return t*t*integrals\n\n    def generator(self, approximated=False):\n        superop = 0\n        if type(self.Hsys) != np.ndarray:\n            evals, all_state = self.Hsys.eigenstates()\n        else:\n            evals, all_state = np.linalg.eig(self.Hsys)\n            all_state = [i.reshape((len(i), 1)) for i in all_state]\n\n        N = len(all_state)\n        collapse_list = []\n        ws = []\n        for j in range(N):\n            for k in range(j + 1, N):\n                Deltajk = evals[k] - evals[j]\n                ws.append(Deltajk)\n                if type(self.Hsys) != np.ndarray:\n                    collapse_list.append(\n                        (\n                            all_state[j]\n                            * all_state[j].dag()\n                            * self.Q\n                            * all_state[k]\n                            * all_state[k].dag()\n                        )\n                    )  # emission\n                    ws.append(-Deltajk)\n                    collapse_list.append(\n                        (\n                            all_state[k]\n                            * all_state[k].dag()\n                            * self.Q\n                            * all_state[j]\n                            * all_state[j].dag()\n                        )\n                    )  # absorption\n                else:\n                    collapse_list.append(\n                        (\n                            all_state[j]\n                            @ np.conjugate(all_state[j]).T\n                            @ self.Q\n                            @ all_state[k]\n                            @ np.conjugate(all_state[k]).T\n                        )\n                    )  # emission\n                    ws.append(-Deltajk)\n                    collapse_list.append(\n                        (\n                            all_state[k]\n                            @ np.conjugate(all_state[k]).T\n                            @ self.Q\n                            @ all_state[j]\n                            @ np.conjugate(all_state[j]).T\n                        )\n                    )  # absorption\n        collapse_list.append(self.Q - sum(collapse_list))  # Dephasing\n        ws.append(0)\n        eldict = {ws[i]: collapse_list[i] for i in range(len(ws))}\n        dictrem = {}\n        if _qutip:\n            empty = Qobj([[0]*N]*N)\n            for keys, values in eldict.items():\n                if (values != empty):\n                    dictrem[keys] = values\n        else:\n            empty = np.array([[0]*N]*N)\n            for keys, values in eldict.items():\n                if (values != empty).any():\n                    dictrem[keys] = values\n        ws = list(dictrem.keys())\n        eldict = dictrem\n        combinations = list(itertools.product(ws, ws))\n        decays = []\n        matrixform = []\n        rates = {}\n        done = []\n        for i in tqdm(combinations, desc='Calculating Integrals ...'):\n            done.append(i)\n            j = (i[1], i[0])\n            if (j in done) &amp; (i != j):\n                rates[i] = np.conjugate(rates[j])\n            else:\n                rates[i] = self.\u0393gen(i[0], i[1], self.t, approximated)\n\n        for i in tqdm(combinations, desc='Calculating the generator ...'):\n            decays.append(rates[i])\n            if _qutip is False:\n                matrixform.append(\n                    (spre(eldict[i[1]]) * spost(\n                        np.conjugate(eldict[i[0]]).T) -\n                     ((spre(np.conjugate(eldict[i[0]]).T @ eldict[i[1]]) +\n                       spost(np.conjugate(eldict[i[0]]).T @ eldict[i[1]])\n                       )*0.5)))\n            else:\n                matrixform.append(\n                    (spre(eldict[i[1]]) * spost(eldict[i[0]].dag()) -\n                     (0.5 *\n                     (spre(eldict[i[0]].dag() * eldict[i[1]]) + spost(\n                         eldict[i[0]].dag() * eldict[i[1]])))))\n        ll = []\n        superop = []\n        for l in range(len(self.t)):\n            if _qutip:\n                ll = [matrixform[j]*decays[j][l]\n                      for j in range(len(combinations))]\n                superop.append(sum(ll))\n            else:\n                ll = [matrixform[j].right*decays[j][l]\n                      for j in range(len(combinations))]\n                superop.append(sum(ll))\n            ll = []\n        self.generators = superop\n\n    def evolution(self, rho0, approximated=False):\n        r\"\"\"\n        This function computes the evolution of the state $\\rho(0)$\n\n        Parameters\n        ----------\n\n        rho0 : numpy.ndarray or qutip.Qobj\n            The initial state of the quantum system under consideration.\n\n        approximated : bool\n            When False the full cumulant equation/refined weak coupling is\n            computed, when True the Filtered Approximation (FA is computed),\n            this greatly reduces computational time, at the expense of\n            diminishing accuracy particularly for the populations of the system\n            at early times.\n\n        Returns\n        -------\n        list\n            a list containing all of the density matrices, at all timesteps of\n            the evolution\n        \"\"\"\n        self.generator(approximated)\n        if _qutip:\n            states=[(i).expm()(rho0) for i in tqdm(self.generators,\n                    desc='Computing Exponential of Generators . . . .')]\n        else:\n            states=[(expm(i)@(rho0.reshape(rho0.shape[0]**2)))\n                    .reshape(rho0.shape)\n                    for i in tqdm(self.generators,\n                    desc='Computing Exponential of Generators . . . .')]\n        return [(-1j*self.Hsys*self.t[i]).expm()*states[i]*\n                (1j*self.Hsys*self.t[i]).expm() for i in range(len(self.t))]\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.evolution","title":"<code>evolution(rho0, approximated=False)</code>","text":"<p>This function computes the evolution of the state \\(\\rho(0)\\)</p> <p>Parameters:</p> Name Type Description Default <code>rho0</code> <code>ndarray or Qobj</code> <p>The initial state of the quantum system under consideration.</p> required <code>approximated</code> <code>bool</code> <p>When False the full cumulant equation/refined weak coupling is computed, when True the Filtered Approximation (FA is computed), this greatly reduces computational time, at the expense of diminishing accuracy particularly for the populations of the system at early times.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>a list containing all of the density matrices, at all timesteps of the evolution</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def evolution(self, rho0, approximated=False):\n    r\"\"\"\n    This function computes the evolution of the state $\\rho(0)$\n\n    Parameters\n    ----------\n\n    rho0 : numpy.ndarray or qutip.Qobj\n        The initial state of the quantum system under consideration.\n\n    approximated : bool\n        When False the full cumulant equation/refined weak coupling is\n        computed, when True the Filtered Approximation (FA is computed),\n        this greatly reduces computational time, at the expense of\n        diminishing accuracy particularly for the populations of the system\n        at early times.\n\n    Returns\n    -------\n    list\n        a list containing all of the density matrices, at all timesteps of\n        the evolution\n    \"\"\"\n    self.generator(approximated)\n    if _qutip:\n        states=[(i).expm()(rho0) for i in tqdm(self.generators,\n                desc='Computing Exponential of Generators . . . .')]\n    else:\n        states=[(expm(i)@(rho0.reshape(rho0.shape[0]**2)))\n                .reshape(rho0.shape)\n                for i in tqdm(self.generators,\n                desc='Computing Exponential of Generators . . . .')]\n    return [(-1j*self.Hsys*self.t[i]).expm()*states[i]*\n            (1j*self.Hsys*self.t[i]).expm() for i in range(len(self.t))]\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.\u0393gen","title":"<code>\u0393gen(w, w1, t, approximated=False)</code>","text":"<p>It describes the the decay rates of the cumulant equation for bosonic baths</p> \\[\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega  e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1)  sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right) sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega)  sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right)  sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]\\] <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float or ndarray</code> required <code>w1</code> <code>float or ndarray</code> required <code>t</code> <code>float or ndarray</code> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>It returns a value or array describing the decay between the levels with energies w and w1 at time t</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def \u0393gen(self, w, w1, t, approximated=False):\n    r\"\"\"\n    It describes the the decay rates of the cumulant equation\n    for bosonic baths\n\n    $$\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega \n    e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1) \n    sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right)\n    sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega) \n    sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right) \n    sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]$$\n\n    Parameters\n    ----------\n\n    w : float or numpy.ndarray\n    w1 : float or numpy.ndarray\n    t : float or numpy.ndarray\n\n    Returns\n    -------\n    float or numpy.ndarray\n        It returns a value or array describing the decay between the levels\n        with energies w and w1 at time t\n\n    \"\"\"\n    if approximated:\n        return self.\u03b3fa(w, w1, t)\n    else:\n        integrals = quad_vec(\n            self._\u03b3,\n            0,\n            np.Inf,\n            args=(w, w1, t),\n            epsabs=self.eps,\n            epsrel=self.eps,\n            quadrature=\"gk15\"\n        )[0]\n        return t*t*integrals\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.\u03b3fa","title":"<code>\u03b3fa(w, w1, t)</code>","text":"<p>It describes the decay rates for the Filtered Approximation of the cumulant equation</p> \\[\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)  \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)  \\right)^{\\frac{1}{2}}\\] <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float or ndarray</code> required <code>w1</code> <code>float or ndarray</code> required <code>t</code> <code>float or ndarray</code> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>It returns a value or array describing the decay between the levels with energies w and w1 at time t</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def \u03b3fa(self, w, w1, t):\n    r\"\"\"\n    It describes the decay rates for the Filtered Approximation of the\n    cumulant equation\n\n    $$\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime\n    -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)\n     \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)\n     \\right)^{\\frac{1}{2}}$$\n\n    Parameters\n    ----------\n\n    w : float or numpy.ndarray\n\n    w1 : float or numpy.ndarray\n\n    t : float or numpy.ndarray\n\n    Returns\n    -------\n    float or numpy.ndarray\n        It returns a value or array describing the decay between the levels\n        with energies w and w1 at time t\n\n    \"\"\"\n    var = (2 * np.pi * t * np.exp(1j * (w1 - w) * t / 2)\n           * np.sinc((w1 - w) * t / (2 * np.pi))\n           * np.sqrt(self.spectral_density(w1) * (self.bose(w1) + 1))\n           * np.sqrt(self.spectral_density(w) * (self.bose(w) + 1)))\n    return var\n</code></pre>"},{"location":"example_qutip/","title":"Example 1: The Refined Weak Coupling/ Cumulant equation for a qubit","text":"In\u00a0[1]: Copied! <pre>from nmm import csolve,OverdampedBath\nfrom qutip import Qobj,sigmaz,sigmax,brmesolve\nimport numpy as np\nfrom qutip.nonmarkov.bofin_baths import DrudeLorentzPadeBath\nfrom qutip.nonmarkov.bofin_solvers import HEOMSolver\nfrom scipy.integrate import quad_vec\nfrom scipy import linalg\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n</pre> from nmm import csolve,OverdampedBath from qutip import Qobj,sigmaz,sigmax,brmesolve import numpy as np from qutip.nonmarkov.bofin_baths import DrudeLorentzPadeBath from qutip.nonmarkov.bofin_solvers import HEOMSolver from scipy.integrate import quad_vec from scipy import linalg from tqdm import tqdm import matplotlib.pyplot as plt <p>We now specify the parameters of our simulation</p> In\u00a0[2]: Copied! <pre>w0 = 1\nalpha = 0.05\ngamma = 5*w0\nT = 1*w0\ntf = 4\nt=np.linspace(0,tf,100)\nHsys = sigmaz()/2\nQ = sigmax()\n</pre> w0 = 1 alpha = 0.05 gamma = 5*w0 T = 1*w0 tf = 4 t=np.linspace(0,tf,100) Hsys = sigmaz()/2 Q = sigmax() <p>The refined weak coupling or cumulant equation needs the spectral density to calculate the decay rates, to make simulation easy we included the spectral densities among other bath related functions in bath classes, in this example we want to use a Drude Lorentz overdamped spectral density, so we initialize an OverdampedBath</p> In\u00a0[3]: Copied! <pre>bath=OverdampedBath(T,alpha,gamma)\n</pre> bath=OverdampedBath(T,alpha,gamma) <p>Next we initialize the csolve which is the solver of the cumulant equation, it requires the time grid for our simulation, the system Hamiltonian, The coupling operator $Q$, andd the bath object</p> In\u00a0[4]: Copied! <pre>cc = csolve(Hsys,t ,bath, Q)\n</pre> cc = csolve(Hsys,t ,bath, Q) <p>We now specify our inital state</p> In\u00a0[5]: Copied! <pre>rho0=0.5*Qobj([[1,1],[1,1]])\nrho0\n</pre> rho0=0.5*Qobj([[1,1],[1,1]]) rho0 Out[5]:  Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True $ \\\\ \\left(\\begin{matrix}0.500 &amp; 0.500\\\\0.500 &amp; 0.500\\\\\\end{matrix}\\right)$  In\u00a0[6]: Copied! <pre>result=cc.evolution(rho0)\n</pre> result=cc.evolution(rho0) <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:15&lt;00:00,  3.90s/it]\nCalculating the generator ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 494.00it/s]\nComputing Exponential of Generators . . . .: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 509.73it/s]\n</pre> <p>We know solve the same system with the Hierarchical Equations of motion (HEOM) we use Qutip's implementation. Details can be found here</p> In\u00a0[7]: Copied! <pre>bathh = DrudeLorentzPadeBath(Q=Q, lam=alpha*np.pi, gamma=gamma, T=T, Nk=4)\nsolver = HEOMSolver(Hsys, bathh, max_depth=8)\nresult_h = solver.run(rho0, t)\n</pre> bathh = DrudeLorentzPadeBath(Q=Q, lam=alpha*np.pi, gamma=gamma, T=T, Nk=4) solver = HEOMSolver(Hsys, bathh, max_depth=8) result_h = solver.run(rho0, t) <p>and finally let us use the Bloch-Redfield equation which uses a similar level of approximation as the Refined Weak Coupling/Cumulant Equation</p> In\u00a0[8]: Copied! <pre>DL1=lambda w:bath.power_spectrum(w)*np.pi\na_ops = [[Q, DL1]]\nresultBR = brmesolve(Hsys, rho0, t, a_ops=a_ops,use_secular=False)\n</pre> DL1=lambda w:bath.power_spectrum(w)*np.pi a_ops = [[Q, DL1]] resultBR = brmesolve(Hsys, rho0, t, a_ops=a_ops,use_secular=False) In\u00a0[9]: Copied! <pre>#Auxiliary function for plotting\ndef population(den, a, b):\n    return [den[i][a, b] for i in range(len(den))]\n</pre> #Auxiliary function for plotting def population(den, a, b):     return [den[i][a, b] for i in range(len(den))] In\u00a0[10]: Copied! <pre>plt.plot(t,population(result_h.states,0,0),label='HEOM')\nplt.plot(t,population(resultBR.states,0,0),label='BR')\nplt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'$\\rho_{11}$',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> plt.plot(t,population(result_h.states,0,0),label='HEOM') plt.plot(t,population(resultBR.states,0,0),label='BR') plt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'$\\rho_{11}$',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show() <pre>/home/mcditoos/miniconda3/envs/nm/lib/python3.12/site-packages/matplotlib/cbook.py:1699: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/home/mcditoos/miniconda3/envs/nm/lib/python3.12/site-packages/matplotlib/cbook.py:1345: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> In\u00a0[11]: Copied! <pre>def bose(\u03bd, T):\n    if T == 0:\n        return 0\n    if \u03bd == 0:\n        return 0\n    return np.exp(-\u03bd / T) / (1-np.exp(-\u03bd / T))\n\n\ndef spectral_density(w, lam, gamma):\n    return 2 * w * lam * gamma / (gamma**2 + w**2)\n\n\ndef \u03b3(\u03bd, w, w1, T, t, gamma, lam):\n    var = (\n        t * t * np.exp(1j * (w - w1) / 2 * t) *\n        spectral_density(\u03bd, lam, gamma) *\n        (np.sinc((w - \u03bd) / (2 * np.pi) * t) * np.sinc((w1 - \u03bd) / (2 * np.pi) * t)) *\n        (bose(\u03bd, T) + 1))\n    var += (\n        t\n        * t\n        * np.exp(1j * (w - w1) / 2 * t)\n        * spectral_density(\u03bd, lam, gamma)\n        * (np.sinc((w + \u03bd) / (2 * np.pi) * t) * np.sinc((w1 + \u03bd) / (2 * np.pi) * t))\n        * bose(\u03bd, T)\n    )\n    return var\n\n\ndef \u0393plus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, w, w, T, t, wc, lam),\n    0,\n    np.Inf,\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n    quadrature=\"gk15\",\n)[0]\n\n\ndef \u0393minus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, -w, -w, T, t, wc, lam),\n    0,\n    np.Inf,\n    quadrature=\"gk15\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393plusminus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, w, -w, T, t, wc, lam),\n    0,\n    np.Inf,\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zplus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, w, T, t, wc, lam),\n    0,\n    np.Inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zminus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, -w, T, t, wc, lam),\n    0,\n    np.Inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zz(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, 0, T, t, wc, lam),\n    0,\n    np.Inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\n\ndef M(w, T, lam, t, f1, f2, f3, wc, \u03f5):\n    f = f1 - 1j * f2\n    gplus = (np.abs(f) ** 2) * \u0393plus(w, T, t, wc, lam, \u03f5)\n    gminus = (np.abs(f) ** 2) * \u0393minus(w, T, t, wc, lam, \u03f5)\n    gzplus = np.conjugate(f) * f3 * \u0393zplus(w, T, t, wc, lam, \u03f5)\n    gzminus = f * f3 * \u0393zminus(w, T, t, wc, lam, \u03f5)\n    gamma = gplus + gminus\n    l = np.conjugate(gzplus) + gzminus\n    A = np.conjugate(gzplus) - gzminus\n    plusminus = f**2 * \u0393plusminus(w, T, t, wc, lam, \u03f5)\n    gammazz = 2 * f3**2 * \u0393zz(w, T, t, wc, lam, \u03f5)\n    xiz = 0  # These are included to show the full matrix as in 1\n    xi = 0  # but LS corrections are not included here\n    matriz = np.array(\n        [\n            [-gamma, xiz * f2 + np.real(l), -xiz * f1 - np.imag(l)],\n            [\n                np.real(l) - f2 * xiz,\n                np.real(plusminus) - (gamma / 2) - gammazz,\n                -xi - np.imag(plusminus),\n            ],\n            [\n                -np.imag(l) + f1 * xiz,\n                xi - np.imag(plusminus),\n                - np.real(plusminus) - (gamma / 2) - gammazz,\n            ],\n        ]\n    )\n    r = [\n        (gminus - gplus) / 2,\n        np.real(A),\n        -np.imag(A),\n    ]\n    return matriz, r\n\n\ndef dynamics(w, T, t, lam, f1, f2, f3, wc, \u03f5, a):\n    s1 = np.array([[0, 1], [1, 0]])\n    s2 = np.array([[0, -1j], [1j, 0]])\n    s3 = np.array([[1, 0], [0, -1]])\n    if t == 0:\n        return (np.eye(2) / 2) + a[0] * s3 + a[2] * s2 + a[1] * s1\n    m, r = M(w, T, lam, t, f1, f2, f3, wc, \u03f5)\n    if (f1 == f2) &amp; (f2 == 0):\n        m = m[1:, 1:]\n        # print(m.shape)\n        exponential = linalg.expm(m)\n        pauli_coeff = (exponential - np.eye(2)) @ np.linalg.inv(m) @ r[1:]\n        with_pauli = pauli_coeff[0] * s1 + pauli_coeff[1] * s2\n        transient = exponential @ a[1:]\n        transient_base = transient[0] * s1 + transient[1] * s2\n        total = (np.eye(2) / 2) + transient_base + with_pauli + a[0] * s3\n        return total\n    exponential = linalg.expm(m)\n    pauli_coeff = (exponential - np.eye(3)) @ np.linalg.inv(m) @ r\n    with_pauli = pauli_coeff[0] * s3 + pauli_coeff[1] * s1 + pauli_coeff[2] * s2\n    transient = exponential @ a\n    transient_base = transient[0] * s3 + transient[1] * s1 + transient[2] * s2\n    total = (np.eye(2) / 2) + transient_base + with_pauli\n    return total\n\ndef rotation(data, t):\n    sz = np.array([[1, 0], [0, -1]])\n    rotated = [\n        linalg.expm(-(1j * sz / 2) * t[i])\n        @ np.array(data)[i]\n        @ linalg.expm((1j * sz / 2) * t[i])\n        for i in tqdm(range(len(t)), desc=f\"Computing for all t, currently on \")\n    ]\n    return rotated\n\ndef cumulant(\n    t, w, T, lam, f1, f2, f3, a, b, c, gamma, \u03f5, dm=True, l=10, t0=0\n):\n    t = np.linspace(t0, t, l)\n    data = [\n        dynamics(w, T, i, lam, f1, f2, f3, gamma, \u03f5, [a, b, c])\n        for i in tqdm(t, desc=f\"Computing for all t, currently on \")\n    ]\n    data = rotation(data, t)\n    if dm:\n        return data\n    \u03c111 = np.array([data[i][0, 0] for i in range(len(data))])\n    \u03c112 = np.array([data[i][0, 1] for i in range(len(data))])\n    \u03c121 = np.array([data[i][1, 0] for i in range(len(data))])\n    \u03c122 = np.array([data[i][1, 1] for i in range(len(data))])\n    return \u03c111, \u03c112, \u03c121, \u03c122\n</pre> def bose(\u03bd, T):     if T == 0:         return 0     if \u03bd == 0:         return 0     return np.exp(-\u03bd / T) / (1-np.exp(-\u03bd / T))   def spectral_density(w, lam, gamma):     return 2 * w * lam * gamma / (gamma**2 + w**2)   def \u03b3(\u03bd, w, w1, T, t, gamma, lam):     var = (         t * t * np.exp(1j * (w - w1) / 2 * t) *         spectral_density(\u03bd, lam, gamma) *         (np.sinc((w - \u03bd) / (2 * np.pi) * t) * np.sinc((w1 - \u03bd) / (2 * np.pi) * t)) *         (bose(\u03bd, T) + 1))     var += (         t         * t         * np.exp(1j * (w - w1) / 2 * t)         * spectral_density(\u03bd, lam, gamma)         * (np.sinc((w + \u03bd) / (2 * np.pi) * t) * np.sinc((w1 + \u03bd) / (2 * np.pi) * t))         * bose(\u03bd, T)     )     return var   def \u0393plus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, w, w, T, t, wc, lam),     0,     np.Inf,     epsabs=\u03f5,     epsrel=\u03f5,     quadrature=\"gk15\", )[0]   def \u0393minus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, -w, -w, T, t, wc, lam),     0,     np.Inf,     quadrature=\"gk15\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393plusminus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, w, -w, T, t, wc, lam),     0,     np.Inf,     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zplus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, w, T, t, wc, lam),     0,     np.Inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zminus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, -w, T, t, wc, lam),     0,     np.Inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zz(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, 0, T, t, wc, lam),     0,     np.Inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]    def M(w, T, lam, t, f1, f2, f3, wc, \u03f5):     f = f1 - 1j * f2     gplus = (np.abs(f) ** 2) * \u0393plus(w, T, t, wc, lam, \u03f5)     gminus = (np.abs(f) ** 2) * \u0393minus(w, T, t, wc, lam, \u03f5)     gzplus = np.conjugate(f) * f3 * \u0393zplus(w, T, t, wc, lam, \u03f5)     gzminus = f * f3 * \u0393zminus(w, T, t, wc, lam, \u03f5)     gamma = gplus + gminus     l = np.conjugate(gzplus) + gzminus     A = np.conjugate(gzplus) - gzminus     plusminus = f**2 * \u0393plusminus(w, T, t, wc, lam, \u03f5)     gammazz = 2 * f3**2 * \u0393zz(w, T, t, wc, lam, \u03f5)     xiz = 0  # These are included to show the full matrix as in 1     xi = 0  # but LS corrections are not included here     matriz = np.array(         [             [-gamma, xiz * f2 + np.real(l), -xiz * f1 - np.imag(l)],             [                 np.real(l) - f2 * xiz,                 np.real(plusminus) - (gamma / 2) - gammazz,                 -xi - np.imag(plusminus),             ],             [                 -np.imag(l) + f1 * xiz,                 xi - np.imag(plusminus),                 - np.real(plusminus) - (gamma / 2) - gammazz,             ],         ]     )     r = [         (gminus - gplus) / 2,         np.real(A),         -np.imag(A),     ]     return matriz, r   def dynamics(w, T, t, lam, f1, f2, f3, wc, \u03f5, a):     s1 = np.array([[0, 1], [1, 0]])     s2 = np.array([[0, -1j], [1j, 0]])     s3 = np.array([[1, 0], [0, -1]])     if t == 0:         return (np.eye(2) / 2) + a[0] * s3 + a[2] * s2 + a[1] * s1     m, r = M(w, T, lam, t, f1, f2, f3, wc, \u03f5)     if (f1 == f2) &amp; (f2 == 0):         m = m[1:, 1:]         # print(m.shape)         exponential = linalg.expm(m)         pauli_coeff = (exponential - np.eye(2)) @ np.linalg.inv(m) @ r[1:]         with_pauli = pauli_coeff[0] * s1 + pauli_coeff[1] * s2         transient = exponential @ a[1:]         transient_base = transient[0] * s1 + transient[1] * s2         total = (np.eye(2) / 2) + transient_base + with_pauli + a[0] * s3         return total     exponential = linalg.expm(m)     pauli_coeff = (exponential - np.eye(3)) @ np.linalg.inv(m) @ r     with_pauli = pauli_coeff[0] * s3 + pauli_coeff[1] * s1 + pauli_coeff[2] * s2     transient = exponential @ a     transient_base = transient[0] * s3 + transient[1] * s1 + transient[2] * s2     total = (np.eye(2) / 2) + transient_base + with_pauli     return total  def rotation(data, t):     sz = np.array([[1, 0], [0, -1]])     rotated = [         linalg.expm(-(1j * sz / 2) * t[i])         @ np.array(data)[i]         @ linalg.expm((1j * sz / 2) * t[i])         for i in tqdm(range(len(t)), desc=f\"Computing for all t, currently on \")     ]     return rotated  def cumulant(     t, w, T, lam, f1, f2, f3, a, b, c, gamma, \u03f5, dm=True, l=10, t0=0 ):     t = np.linspace(t0, t, l)     data = [         dynamics(w, T, i, lam, f1, f2, f3, gamma, \u03f5, [a, b, c])         for i in tqdm(t, desc=f\"Computing for all t, currently on \")     ]     data = rotation(data, t)     if dm:         return data     \u03c111 = np.array([data[i][0, 0] for i in range(len(data))])     \u03c112 = np.array([data[i][0, 1] for i in range(len(data))])     \u03c121 = np.array([data[i][1, 0] for i in range(len(data))])     \u03c122 = np.array([data[i][1, 1] for i in range(len(data))])     return \u03c111, \u03c112, \u03c121, \u03c122 In\u00a0[12]: Copied! <pre>cum2=cumulant(t[-1],w0,T,alpha,1,0,0,0,0.5,0,gamma,1e-3)\n</pre> cum2=cumulant(t[-1],w0,T,alpha,1,0,0,0,0.5,0,gamma,1e-3) <pre>Computing for all t, currently on :   0%|          | 0/10 [00:00&lt;?, ?it/s]</pre> <pre>Computing for all t, currently on : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:03&lt;00:00,  3.30it/s]\nComputing for all t, currently on : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00&lt;00:00, 1866.62it/s]\n</pre> In\u00a0[13]: Copied! <pre>t2=np.linspace(0,t[-1],len(cum2))\nplt.scatter(t2,population(cum2,0,1),label='Cumulant in Linear Map Form')\nplt.plot(t,population(result_h.states,0,1),label='HEOM')\nplt.plot(t,population(resultBR.states,0,1),label='BR')\nplt.plot(t,population(result,0,1),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'Re($\\rho_{12}$)',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> t2=np.linspace(0,t[-1],len(cum2)) plt.scatter(t2,population(cum2,0,1),label='Cumulant in Linear Map Form') plt.plot(t,population(result_h.states,0,1),label='HEOM') plt.plot(t,population(resultBR.states,0,1),label='BR') plt.plot(t,population(result,0,1),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'Re($\\rho_{12}$)',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show() <pre>/home/mcditoos/miniconda3/envs/nm/lib/python3.12/site-packages/matplotlib/collections.py:194: ComplexWarning: Casting complex values to real discards the imaginary part\n  offsets = np.asanyarray(offsets, float)\n</pre> In\u00a0[14]: Copied! <pre>plt.scatter(t2,population(cum2,0,0),label='Cumulant in Linear Map Form')\nplt.plot(t,population(result_h.states,0,0),label='HEOM')\nplt.plot(t,population(resultBR.states,0,0),label='BR')\nplt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'$\\rho_{11}$',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> plt.scatter(t2,population(cum2,0,0),label='Cumulant in Linear Map Form') plt.plot(t,population(result_h.states,0,0),label='HEOM') plt.plot(t,population(resultBR.states,0,0),label='BR') plt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'$\\rho_{11}$',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show()"},{"location":"example_qutip/#example-1-the-refined-weak-coupling-cumulant-equation-for-a-qubit","title":"Example 1: The Refined Weak Coupling/ Cumulant equation for a qubit\u00b6","text":"<p>In this notebook we illustrate the simulation of a qubit using nmm, we follow the notation in 1, where the Hamiltonian of the spin-boson model is given by</p> <p>\\begin{align}      H = \\underbrace{\\frac{\\omega_{0}}{2} \\sigma_{z}}_{H_S} + \\underbrace{\\sum_{k} w_{k} a_{k}^{\\dagger} a_{k}}_{H_B} + \\underbrace{\\sum_{k} g_k (f_1 \\sigma_{x}+f_2 \\sigma_{y} +f_3 \\sigma_{z}) (a_{k}+a_{k}^{\\dagger})}_{H_I} \\end{align}</p> <p>We first begin by importing the necessary packages</p>"},{"location":"example_qutip/#let-us-compare-with-the-semi-analytical-form-of-the-cumulantrefined-weak-coupling-for-a-qubit-1","title":"Let us compare with the semi-analytical form of the cumulant/refined weak coupling for a qubit 1\u00b6","text":""},{"location":"tutorial/","title":"Under construction","text":""}]}